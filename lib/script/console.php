#!/bin/sh
# vim: ft=php

# This is just a wrapper to optionally run the console with rlwrap
if which rlwrap &>/dev/null; then
   exec rlwrap -c -r -s 1000 php5 -d output_buffering=On $0 "$@"
else
   exec php5 -d output_buffering=On $0 "$@"
fi

<?
# Copyright 2008 Markus Koller
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the MIT License.
#
# $Id$
#

   # Clean the output generated by the shell-script wrapper
   ob_end_clean();

   if (!is_resource(STDIN)) {
      die("Can't read standard input!\n");
   }

   $log_level = LOG_INFO;

   $args = array_slice($argv, 1);
   while ($arg = array_shift($args)) {
      switch ($arg) {
         case '-v':
            # Be verbose
            $log_level = LOG_DEBUG;
            break;
         case '-q':
            # Don't show log messages
            $log_level = LOG_DISABLED;
            break;
         case '-s':
            # Don't show prompts
            define('SILENT', true);
            break;
         case '-e':
            # Execute given command and exit
            if ($command = array_shift($args)) {
               $quiet = ($log_level == LOG_DISABLED ? '-q' : '');
               system("echo '$command' | php5 -d output_buffering=On {$argv[0]} -s $quiet", $status);
               exit($status);
            } else {
               usage();
            }
            break;
         case '-p':
            $_ENV['ENVIRONMENT'] = 'production';
            break;
         case '-d':
            $_ENV['ENVIRONMENT'] = 'development';
            break;
         case '-t':
            $_ENV['ENVIRONMENT'] = 'test';
            break;
         default:
            usage();
      }
   }

   unset($args);
   unset($arg);

   require_once dirname(__FILE__).'/../script.php';

   log_level_set($log_level);
   unset($log_level);

   prompt("\n\n".`php -v`."\n");
   prompt("Loading [1m".ENVIRONMENT."[0m environment\n\n");

   while (!feof(STDIN)) {
      prompt("php[".config('name')."] >>> ");
      $_command = trim(fgets(STDIN));

      # Show help
      if (in_array($_command, array('?', 'help'))) {
         print "\n";
         print "  Special commands:\n";
         print "    help, ?               Show this help\n";
         print "    help FUNCTION         Show function signature\n";
         print "    exit, quit            Exit the console\n";
         print "    time [COUNT] CODE     Show execution time\n";
         print "    sql [DATABASE] QUERY  Execute SQL query\n";
         print "    ls, cd                Shell aliases\n";
         print "\n";
         print "  Helpers:\n";
         print "    get(\$path, \$params)\n";
         print "    post(\$path, \$params)\n";
         print "    follow()\n";
         print "\n";
         continue;
      }

      # Show function help
      elseif (substr($_command, 0, 5) == 'help ') {
         print dump_function(substr($_command, 5));
         continue;
      }

      # Exit the console
      elseif (in_array($_command, array('exit', 'quit'))) {
         exit;
      }

      # Show execution time
      elseif (substr($_command, 0, 5) == 'time ') {
         $_command = substr($_command, 5);
         if (($_count = (int) $_command) > 0) {
            if ($_command = substr($_command, strlen($_count))) {
               $_command = "for (\$_i = 0; \$_i < $_count; \$_i++) { $_command; }";
            }
         }

         if ($_command) {
            $_command = 'print ""; $_start = microtime(true); '.$_command
                     . '; printf("\n%.5f seconds\n", microtime(true) - $_start)';
         }
      }

      # Execute SQL query
      elseif (substr($_command, 0, 4) == 'sql ') {
         $_command = trim(substr($_command, 4));
         print "$_command\n";

         list($db, $query) = explode(' ', $_command, 2);
         if ($db and config('database', $db)) {
            $db = DB($db);
         } else {
            $db = DB();
            $query = $_command;
         }

         $start = microtime(true);

         try {
            $result = $db->execute($query);
         } catch (Exception $e) {
            print dump_exception($e);
            continue;
         }

         $columns = array();
         $strings = array();
         for ($i = 0; $i < $result->columnCount(); $i++) {
            $column = $result->getColumnMeta($i);
            $columns[$column['name']] = mb_strlen($column['name']);

            if ($column['native_type'] == 'VAR_STRING') {
               $strings[] = $column['name'];
            }
         }

         $rows = $result->fetch_all();
         foreach ($rows as $row) {
            foreach ($row as $key => $value) {
               $columns[$key] = max(is_null($value) ? 4 : mb_strlen($value), $columns[$key]);
            }
         }

         $time = microtime(true) - $start;

         print "\n";
         if ($rows) {
            print "+";
            foreach ($columns as $key => $length) {
               printf("-%{$length}s-+", str_repeat('-', $length));
            }
            print "\n";

            print "|";
            foreach ($columns as $key => $length) {
               printf(" %-{$length}s |", $key);
            }
            print "\n";

            print "+";
            foreach ($columns as $key => $length) {
               printf("-%{$length}s-+", str_repeat('-', $length));
            }
            print "\n";

            foreach ($rows as $row) {
               print "|";
               foreach ($row as $key => $value) {
                  $align = (in_array($key, $strings) ? '-' : '');
                  printf(" %$align{$columns[$key]}s |", is_null($value) ? 'NULL' : $value);
               }
               print "\n";
            }

            print "+";
            foreach ($columns as $key => $length) {
               printf("-%{$length}s-+", str_repeat('-', $length));
            }
            print "\n";

            printf("%s in set", pluralize(count($rows), 'row'));
         } else {
            print "Empty set";
         }

         printf(" (%.2f sec)\n\n", $time);

         continue;
      }

      # 'ls' wrapper
      elseif (trim(substr($_command, 0, 3)) == 'ls') {
         print `$_command -C --color`;
         continue;
      }

      # 'cd' wrapper
      elseif (substr($_command, 0, 3) == 'cd ') {
         chdir(substr($_command, 3));
         print getcwd()."\n";
         continue;
      }

      # 'cd ..' wrapper
      elseif ($_command == '..') {
         chdir('..');
         print getcwd()."\n";
         continue;
      }

      # Execute files
      elseif (substr($_command, 0, 1) == '!') {
         $_shell_command = substr($_command, 1);
         $_command = 'system($_shell_command)';
      }

      # Execute normal PHP code
      else {
         $_command = rtrim($_command, ';');
      }

      if ($_command) {
         # Check for statements and definitions, which don't have a return value
         if (preg_match('/^([a-z]+) /', $_command, $_m) and !in_array($_m[1], array('new', 'null'))) {
            $_result = 'statement';
         } else {
            $_command = "\$_result = ($_command)";
         }

         # Evaluate the command and capture the output
         try {
            ob_start();
            eval("$_command;");
         }

         # Dump exceptions with colored backtrace
         catch (Exception $_e) {
            while (ob_get_level() > 1) {
               ob_end_clean();
            }

            print dump_exception($_e);
            $_result = $_e;
         }

         while (ob_get_level() > 1) {
            ob_end_clean();
         }

         # Show command output
         if ($_output = ob_get_clean()) {
            print rtrim($_output)."\n";
         }

         # Show return value
         prompt(" :: [0;36m".dump_value($_result)."[0m\n");
      }

      $_ = $_result;
   }

   # Generate a fake error so the fatal error handler
   # won't pick up syntax errors from eval
   $fatal_error_handler['shut_up'];

   prompt("\n");
   exit;

   # Helper functions

   function usage() {
      print "Usage: {$GLOBALS['argv'][0]} [OPTIONS]\n"
          . "\n"
          . "  -v       Show debug messages\n"
          . "  -q       Don't show log messages\n"
          . "  -s       Don't show prompt\n"
          . "  -e CODE  Execute code and exit\n"
          . "\n"
          . "  -p       Load production environment\n"
          . "  -d       Load development environment\n"
          . "  -t       Load test environment\n"
          . "\n";
      exit(255);
   }

   function prompt($message) {
      if (!defined('SILENT')) {
         print $message;
      }
   }

   # Perform a request for the given path, with the given HTTP method
   function request($method, $path) {
      if ($GLOBALS['_path']) {
         $GLOBALS['_previous'] = $GLOBALS['_path'];
      }

      $_SERVER['REQUEST_METHOD'] = $method;
      $_SERVER['REQUEST_URI'] = $GLOBALS['_path'] = '/'.ltrim($path, '/');

      $c = $GLOBALS['_controller'] = Dispatcher::run($path);
      if ($c->msg) {
         var_export($c->msg);
      }

      return $c;
   }

   # Wrapper for GET requests
   function get($path, array $params=null) {
      if (is_array($params)) {
         $_GET = $params;
         $_POST = array();
      }

      return request('GET', $path);
   }

   # Wrapper for POST requests
   function post($path, array $params=null) {
      if (is_array($path) and is_null($params)) {
         if ($c = $GLOBALS['_controller'] and
               preg_match('/<form.*? action="([^"]+)"/', $c->output, $match)) {
            $params = $path;
            $path = $match[1];
         } else {
            print "\n  Couldn't find current form\n\n";
            return;
         }
      }

      $_GET = $_POST = (array) $params;
      return request('POST', $path);
   }

   # Follow a redirect
   function follow() {
      if ($c = $GLOBALS['_controller'] and
          $location = $c->headers['Location'] and
          $c->headers['Status'])
      {
         $path = str_replace('http://www.example.com/', '', $location);
         return get($path);
      }
   }

   # Follow a link
   function click($link) {
      if ($c = $GLOBALS['_controller'] and
          preg_match('/<a[^>]* href="([^"]+)"[^>]*>\s*'.preg_quote($link).'/', $c->output, $match)) {
         return get($match[1]);
      } else {
         print "  Couldn't find link '$link'";
      }
   }

   # Relaod the current path
   function refresh() {
      if ($path = $GLOBALS['_path']) {
         return get($path);
      } else {
         print "  Couldn't find current path";
      }
   }

   # Go back to the previous path
   function back() {
      if ($path = $GLOBALS['_previous']) {
         return get($path);
      } else {
         print "  Couldn't find previous path";
      }
   }

?>
